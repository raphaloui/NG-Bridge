<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <title>WCV - Sistema Integrato di Produttività Creativa Spaziale</title>
    <style>
        /* Stili CSS di base per il pannello di notifica (se usi un iframe) */
        body {
            font-family: Arial, sans-serif;
            color: white;
            background-color: transparent;
            margin: 0;
            padding: 10px;
        }
        #status-message {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 5px;
            opacity: 0;
            transition: opacity 0.5s;
        }
        .active {
            opacity: 1 !important;
        }
    </style>
</head>
<body>

    <div id="status-message">Benvenuto nel WCV!</div>

    <script>
        // ===================================================================
        // 1. COSTANTI E CONFIGURAZIONE ESSENZIALE
        // ===================================================================

        // INCOLLA QUI L'URL DEL TUO WEB BRIDGE (ottenuto dal deploy di Apps Script)
        const WEB_BRIDGE_URL = 'https://script.google.com/macros/s/AKfycbwTgBQcNG_egxOUXy13FKquWcvUv5TgVaBGfTNmWmk5Nhvk5SaPRJyw1YBYNsp-kIr5DA/exec';

        // UUID DI TUTTE LE POSTAZIONI DI COMANDO (Questi devono corrispondere agli ID reali in Noda!)
        // Coordinate e ID di esempio per la logica di collisione (da adattare al tuo spazio Noda)
        const TARGETS = [
            { id: 'FRULLATORE_IDEE', x: 10, z: 0, radius: 5, action: 'PROCESS_TEXT_LLM' },
            { id: 'GEMMA_SPAZIALE', x: 25, z: 0, radius: 5, action: 'GENERATIVE_VISUAL_REPRESENTATION' },
            { id: 'EMAIL_HUB', x: 40, z: 0, radius: 5, action: 'SEND_EMAIL' },
            { id: 'KEEP_HUB', x: 55, z: 0, radius: 5, action: 'CREATE_NOTE' },
            { id: 'CRITICAL_STATUS_HUB', x: 70, z: 0, radius: 5, action: 'APPLY_VFX_BY_TAG' },
            { id: 'VOID_ZONE', x: 90, z: 0, radius: 8, action: 'INCINERATE_NODE' } // Usato anche per onNodeHit
            // Aggiungi qui CODE_RUNNER, TIMER, RECINTI, ecc.
        ];

        // ===================================================================
        // 2. FUNZIONE DI COMUNICAZIONE (sendCommand)
        // ===================================================================

        function eventMessage(msg) {
            const el = document.getElementById('status-message');
            el.textContent = msg;
            el.classList.add('active');
            setTimeout(() => {
                el.classList.remove('active');
            }, 5000);
        }

        async function sendCommand(action, nodeId, nodeTitle, nodeNotes, pageUrl, targetId, recipientEmail = null, metadata = {}) {
            const payload = { 
                action, nodeId, nodeTitle, nodeNotes, pageUrl, targetId, recipientEmail, metadata
            };
            
            eventMessage(`Invio comando: ${action}...`);

            try {
                const response = await fetch(WEB_BRIDGE_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'text/plain' }, // Importante per Google Apps Script
                    body: JSON.stringify(payload)
                });
                
                const text = await response.text();

                // Gestione della risposta JSON per la Gemma Spaziale
                if (action === 'GENERATIVE_VISUAL_REPRESENTATION') {
                    try {
                        return JSON.parse(text);
                    } catch (e) {
                        eventMessage(`ERRORE: Risposta JSON non valida dal backend. Controlla GAS logs.`);
                        return { error: text };
                    }
                }

                return text; // Ritorna stringa per gli altri comandi
            } catch (error) {
                eventMessage(`ERRORE di rete: ${error.message}`);
                return `SERVER_ERROR: ${error.message}`;
            }
        }

        // ===================================================================
        // 3. LOGICA DI COLLISIONE E LANCIO (onNodeUpdated)
        // ===================================================================

        // Funzione per trovare la postazione colpita (DEVE ESSERE PRECISA nel tuo ambiente Noda)
        function findTargetByLocation(location) {
            // Questa è una simulazione semplificata basata sulle coordinate.
            // In un ambiente Noda reale, usi le API di Noda per rilevare la collisione del nodo con un altro oggetto
            // o devi estrarre il targetId dall'evento se l'API lo fornisce.
            
            // SIMULAZIONE: Controlla la distanza dai centri delle postazioni
            for (const target of TARGETS) {
                const distance = Math.sqrt(
                    Math.pow(location.x - target.x, 2) + 
                    Math.pow(location.z - target.z, 2)
                );
                if (distance < target.radius) {
                    return target;
                }
            }
            return null;
        }


        window.noda.onNodeUpdated = async (node) => { 
            // La logica di collisione/lancio dovrebbe essere gestita qui o tramite un evento di collisione di Noda.
            // Se il nodo è "lanciato" (ad esempio, la sua velocità è alta), controlliamo la posizione finale.
            
            // SIMULAZIONE: Assumiamo che il nodo sia stato lanciato e si sia fermato in location.
            const target = findTargetByLocation(node.location);

            if (target) {
                let response;
                
                switch (target.action) {
                    
                    case 'PROCESS_TEXT_LLM': // FRULLATORE DI IDEE
                        response = await sendCommand(target.action, node.uuid, node.title, node.notes, node.pageUrl, target.id);
                        window.noda.updateNode({ uuid: node.uuid, notes: response });
                        window.noda.playSound({ type: 'SFX_SUCCESS' });
                        eventMessage(`Frullatore: Note processate da Gemini.`);
                        break;
                        
                    case 'EMAIL_HUB': // EMAIL: INVIO
                        const recipient = prompt("Destinatario e-mail:"); 
                        if (recipient) {
                            response = await sendCommand(target.action, node.uuid, node.title, node.notes, node.pageUrl, target.id, recipient);
                            if (response.includes("SUCCESS")) {
                                window.noda.deleteNode({ uuid: node.uuid });
                                window.noda.playSound({ type: 'SFX_WHOOSH' });
                                eventMessage(`E-mail inviata con successo a ${recipient}.`);
                            }
                        }
                        break;

                    case 'CREATE_NOTE': // KEEP: CREAZIONE NOTA
                        response = await sendCommand(target.action, node.uuid, node.title, node.notes, node.pageUrl, target.id);
                        if (response.includes("SUCCESS")) {
                            window.noda.deleteNode({ uuid: node.uuid }); 
                            window.noda.playSound({ type: 'SFX_TRANSFER' });
                            eventMessage(`Nota trasferita a Google Keep.`);
                        }
                        break;
                        
                    case 'GENERATIVE_VISUAL_REPRESENTATION': // GEMMA SPAZIALE (Ramificazione)
                        const data = await sendCommand(target.action, node.uuid, node.title, node.notes, node.pageUrl, target.id);
                        
                        if (data.error) { eventMessage(`ERRORE GEMMA: ${data.error}`); return; }

                        if (data.visualUrl) {
                            // Applica la visualizzazione al nodo genitore
                            window.noda.updateNode({ uuid: node.uuid, imageUrl: data.visualUrl, form: 'PLANAR_QUAD', size: 8.0 });
                        }
                        
                        if (data.newNodes) {
                            // Germogliazione: crea i nodi figli
                            data.newNodes.forEach((newNodeData, index) => {
                                const angle = (index / data.newNodes.length) * 360;
                                const radius = 10;
                                
                                window.noda.createNode({
                                    title: newNodeData.title,
                                    notes: newNodeData.notes,
                                    location: { // Posizionamento in un cerchio attorno al genitore
                                        x: node.location.x + radius * Math.cos(angle * Math.PI / 180), 
                                        y: node.location.y + 1, 
                                        z: node.location.z + radius * Math.sin(angle * Math.PI / 180) 
                                    },
                                    parent: node.uuid, // Collegamento automatico
                                    color: '#00ccff'
                                });
                            });
                            window.noda.playSound({ type: 'SFX_GEMMA_SPAZIALE' });
                            eventMessage(`GEMMA ATTIVATA: Generati ${data.newNodes.length} nuovi rami creativi.`);
                        }
                        break;
                        
                    case 'APPLY_VFX_BY_TAG': // APPLICA FUOCO/FULMINI
                        let vfxType = null;
                        
                        if (node.notes.includes('#POTENZIALE')) {
                            vfxType = 'VFX_FULMINI_BLUE'; 
                        } else if (node.notes.includes('#URGENTE')) {
                            vfxType = 'VFX_FIAMME_ROSSE'; 
                        }

                        if (vfxType) {
                            window.noda.applyVFX({ uuid: node.uuid, effect: vfxType, intensity: 1.0 });
                            window.noda.playSound({ type: 'SFX_ENERGY_CHARGE' });
                            eventMessage(`Nodo potenziato: Applicato VFX critico.`);
                        } else {
                            eventMessage(`Nessun tag critico trovato nel nodo.`);
                        }
                        break;
                }
            }
        };

        // ===================================================================
        // 4. LOGICA DI INTERAZIONE FISICA (Pugno Spaziale)
        // ===================================================================

        window.noda.onNodeHit = async (node, controllerVelocity) => { 
            const VOID_ZONE = TARGETS.find(t => t.id === 'VOID_ZONE');

            if (!VOID_ZONE) return;
            
            // Controllo se il colpo avviene all'interno della VOID_ZONE
            const distToZone = Math.sqrt(
                Math.pow(node.location.x - VOID_ZONE.x, 2) + 
                Math.pow(node.location.z - VOID_ZONE.z, 2)
            );
            
            // Soglia di impatto: Se vicino alla zona e il colpo è forte (magnitudine > 1.5 m/s)
            if (distToZone < VOID_ZONE.radius && controllerVelocity.magnitude > 1.5) { 
                
                // 1. Chiamata backend per pulizia database
                await sendCommand('INCINERATE_NODE', node.uuid, null, null, null, VOID_ZONE.id); 
                
                // 2. Feedback Viscerale
                window.noda.playVFX({ type: 'VFX_EXPLOSION_SMALL', uuid: node.uuid });
                window.noda.playSound({ type: 'SFX_SHATTER' }); // Suono di distruzione
                
                // 3. Eliminazione definitiva
                window.noda.deleteNode({ uuid: node.uuid, delay: 50 }); // Breve ritardo per il VFX
                
                eventMessage(`NODE DISTRUTTO: Eliminato con Pugno Spaziale!`);
            }
        };

        // ===================================================================
        // 5. LOGICA DI GAMIFICATION (Moda e Status)
        // ===================================================================

        // Esempio: Cambia il colore della tuta se in stato di focus
        function checkFocusStatus() {
            // Questa funzione richiederebbe il tracciamento del tempo nel tuo ambiente Noda.
            const TIME_IN_FOCUS_SIMULATED = 1500; // 25 minuti

            if (TIME_IN_FOCUS_SIMULATED > 1200) { 
                // Colore brillante per lo stato di flow
                window.noda.updateAvatarMaterial({ 
                    materialName: 'Tuta', 
                    properties: { color: '#00FFFF', emissiveIntensity: 0.8 } 
                });
            } else {
                // Colore base
                window.noda.updateAvatarMaterial({ 
                    materialName: 'Tuta', 
                    properties: { color: '#555555', emissiveIntensity: 0.1 } 
                });
            }
        }

        // Avvia il controllo dello stato di focus ogni 30 secondi (richiede API Noda avanzate)
        // setInterval(checkFocusStatus, 30000); 

        // Messaggio iniziale
        window.noda.onReady = () => {
            eventMessage("Sistema WCV Noda attivo. Inizia a lanciare i nodi!");
        };

    </script>
</body>
</html>
